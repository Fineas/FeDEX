<!DOCTYPE html>
<html lang="en">
  <head>
    <!-- Required meta tags -->
    <meta charset="utf-8">
    <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">
    <title>FeDEX - website</title>

    <link rel="stylesheet" href="https://use.fontawesome.com/releases/v5.6.3/css/all.css" integrity="sha384-UHRtZLI+pbxtHCWp1t77Bi1L4ZtiqrqD80Kn4Z8NTSRyMA2Fd33n5dQ8lWUE00s/" crossorigin="anonymous">
    <link rel="stylesheet" href="../css/bootstrap4-neon-glow.min.css">    
    <link href="https://fonts.googleapis.com/css?family=Roboto" rel="stylesheet">
    <link rel='stylesheet' href='//cdn.jsdelivr.net/font-hack/2.020/css/hack.min.css'>
    <link rel="stylesheet" href="../css/bootstrap4-neon-glow.css">
    
  </head>
  <body>

  <div class="navbar-dark text-white">
    <div class="container">
      <nav class="navbar px-0 navbar-expand-lg navbar-dark">
        <button class="navbar-toggler" type="button" data-toggle="collapse" data-target="#navbarNavAltMarkup" aria-controls="navbarNavAltMarkup" aria-expanded="false" aria-label="Toggle navigation">
          <span class="navbar-toggler-icon"></span>
        </button>
        <div class="collapse navbar-collapse" id="navbarNavAltMarkup">
          <div class="navbar-nav">
            <a href="../index.html" class="pl-md-0 p-3" style="color: white;">HOME</a>
            <a href="../blog.html" class="p-3" style="color: white;">BLOG</a>
            <a href="../about.html" class="p-3" style="color: white;">ABOUT</a>
          </div>
        </div>
      </nav>

    </div>
  </div>


  
<div class="container py-5 mb5">

  <!-- POST TITLE -->
  
  <div class="row py-4">
    <h1 class="mb-5"><span style="color:#ff707f">Chromatic Aberration - v8 exploitation</span></h1>
    <!-- POST info -->
    <div class="col-lg-12 col-md-12 col-sm-12 mb-8">
      <h5 class="d-flex justify-content-between align-items-center mb-3">
        <span class="text-muted">Event: <span style="color:#ffffff">CONFidence CTF 2020 Teaser</span></span>
      </h5>
      <h5 class="d-flex justify-content-between align-items-center mb-3">
        <span class="text-muted">Problem Statement: <span style="color:#ffffff">Pwn our chrome for fun and profit. Ok, it‚Äôs not really Chrome, but it‚Äôs close enough. Let‚Äôs say, it‚Äôs chromatic.The memory limit is 64MB. </span></span>
      </h5>
      <br>
      <!-- INTRODUCTION -->
      <h1><i class="fas fa-info-circle"></i> <span style="color:#17b06b">INTRODUCERE</span></h1>
      <h5>
        Cand vine vorba de <code>Browsers</code>, trebuie remarcat faptul ca asemenea <code>Sistemelor de Operare</code>, acestea alcatuiesc o arie vasta ce cuprinde nenumarate <code>Browser Engines</code>. Prin urmare, exploatarea acestora poate lua diverse forme precum: <code>JavaScript Engine Exploitation</code>, <code>DOM Exploitation</code> ...
In cele ce urmeaza, ne vom opri atentia asupra Exploatarii Enginului de Javascript din Google Chrome numit v8.
      </h5>
      <h5>
        Challenge-ul ne ofera o arhiva care cuprinde niste fisiere pentru a contextualiza setup-ul de pe server, dar cele importante in cazul de fata sunt: <code>patch file (diff.diff)</code>, si executabilul <code>/bin/d8</code> (d8 este numele pentru JavaScript REPL creat de Google pentru v8).
      </h5>
      <!-- EXPLORATION -->
      <h1><i class="fas fa-code-branch"></i> <span style="color:#17b06b">ANALIZA MODIFICARILOR</span></h1>
      <h5>
        Pentru investigarea vulnerabilitatilor voi folosi (<a href="https://cs.chromium.org/chromium/src/v8/src" style="color:#ff707f">https://cs.chromium.org/chromium/src/v8/src</a>) codul sursa.
        <br>
        Analizand fisierul <code>diff.diff</code>, putem observa ca 2 vulnerabilitati au fost introduse in v8:
        <ul>
          <li>
          Prima Vulnerabilitate este un <code>out-of-bounds read</code> pentru orice obiect de tip String.
   Se observa faptul ca bucata de cod responsabila sa restrictioneze accesarea memoriei in afara celei alocate pentru obiect, a fost eliminata. Prin urmare, lucrul acesta ne permite citirea datelor din memorie la offset arbitrar fata de obiect.
          <br><br>
          <img src="src/p1-v1.png" style="width:100%">
          <br><br>
          </li>
          <li>
          A doua vulnerabilitate este un <code>out-of-bounds write</code> introdus in metoda <code>.fill()</code> a obiectelor de tip TypedArray.
   Asemenea vulnerabilitatii anterioare, putem spune ca vulnerabilitatea sare in ochi datorita modului in care schmibarile au fost facute. Segmentul de cod responsabil sa verifice integritatea parametrilor metodei fill, a fost alterat, astfel avem posibilitatea de a suprascrie pana la 100000000 bytes dupa sau inaintea obiectului Typed Array.
          <br><br><img src="src/p1-v2.png" style="width:100%"><br><br>
          </li>
        </ul>
      </h5>
      <!-- DEBUGGING -->
      <h1><i class="fas fa-search"></i> <span style="color:#17b06b">DEBUGGING</span></h1>
      <h5>Pentru a avea acces la cat mai multe informatii, si pentru a putea vizualiza cu usurinta memoria, voi folosi <code>gdb</code>.</h5>
      <h5>Lucrul acesta este foarte usor de realizat: <code>gdb /bin/d8</code>, insa un feature de care dispune d8 este <code>--allow-natives-syntax</code>. Acesta ne ofera acces la o gama variata de <code>runtime functions</code> printre care si <code>%DebugPrint()</code>. </h5>
      <h5>Aceasta functie este foarte folositoare pentru a obtine mai multe informatii despre obiecte.</h5>
      <br>
      <div class="row">
        <div class="col-lg-6">
          <img src="src/p1-gdb.png" style="width:100%">
        </div>
        <div class="col-lg-6">
          <img src="src/p1-str.png" style="width:100%">
        </div>
      </div><br>
      <h5>Folosind aceasta metoda vom putea obtine <code>offsets</code> intre obiecte si vom folosi aceasta informatie in exploatare. O ultima informatie cu privire la debugging, care este foarte importanta, are de-a face cu ultimul bit dintr-o adresa. v8 foloseste acest bit pentru a tine evidenta pointerilor. Astfel, dupa cum se poate observa si in imaginea de mai sus, cand dorim sa vizualizam o adresa trebuie sa scadem acel bit.</h5>
      <!-- EXPLOITATION -->
      <h1><i class="fas fa-bomb"></i> <span style="color:#17b06b">EXPLOATAREA</span></h1>
      <h5>
        Avand cele mentionate anterior in minte, cum am putea ajunge sa obtinem <code>Remote Code Execution</code>?<br>
Vulnerabilitatile introduse sunt foarte puternice, totusi mai e nevoie de putina prelucrare pentru indeplinirea obiectivului propus.
        <ul>
          <li>
            O idee ar fi sa cautam niste <code>function pointers</code> pe care sa-i suprascriem si sa redirectionam executia programului in directia dorita.
            Analizand contexul, observam ca nu exista astfel de pointeri prin prajma obiectelor vulnerabile, astfel, aceasta idee pica ‚ùé
          </li>
          <li>
            O alta idee ar fi sa plasam intr-o zona de memorie cu drepturi de <code>read+write+execute</code> un <code>shellcode</code> prin care sa ne atingem obiectivul.
   Analizand maparile procesului, putem observa ca nu exista o astfel de mapare. 
   Din fericire, JavaScript nu este singurul care ajunge compilat in v8, mai este si <code>WebAssembly</code>.
   Nu am sa detaliez ce este WebAssembly, deoarece nu reprezinta scopul writeup-ului, insa pentru mai multe informatii recomand documentatia: <a style="color:#ff707f" href="https://developer.mozilla.org/en-US/docs/WebAssembly">https://developer.mozilla.org/en-US/docs/WebAssembly</a>.
   Spre deosebire de JIT care utilizeaza un <code>write-protect</code> flag pentru a schimba permisiunile segmentelor de memorie din <code>rw</code> in <code>rx</code> si vice versa, WebAssembly mapeaza o zona de memorie <code>rwx</code> pentru codul compilat ‚úÖ
   <br>
   <center><img src="src/p1-y.png" style="width:50%;"></center>   
        </li>
        </ul>
      </h5>
      <h5>
        Folosind aceasta "proprietate", nu ne ramane decat sa gasim o modalitate de a determina adresa la care este incarcat codul compilat de <code>WASM</code>, si o modalitate de a suprascrie datele din acea zona de memorie.
      </h5>
      <br>
        <h5 style="color:#ff707f">1. Gasirea Zonei de Memorie</h5>
      <br>
      <h5>Vom incepe prin alocarea unui <code>String</code> si crearea unei instante de <code>WASM</code> </h5>
        <code>
          d8> const wasm = new Uint8Array([...]);<br>
          d8> let s = new String("MAMAMAMAMAMAMAM");<br>
          d8> const w_instance = new WebAssembly.Instance(new WebAssembly.Module(wasm));<br>
          d8> %DebugPrint(s)<br>
          ...<br>
          - value: 0x23eb0820f501 <String[16]: MAMAMAMAMAMAMAM> <span style="color:#db5508"><- Stringul se va afla la adresa 0x23eb0820f501-1+0xc</span><br>
          ...<br>
          d8> %DebugPrint(w_instance)<br>
          DebugPrint: 0x23eb0820f829: [WasmInstanceObject] in OldSpace  <span style="color:#db5508"><- Adresa zonei de memorie se gaseste la adresa  0x23eb0820f829-1+0x68</span><br>
          ...<br>
        </code>
        <h5>Asadar, efectuand <small><code>(0x23eb0820f829-1+0x68)-(0x23eb0820f501-1+0xc) </code></small> vom obtine offsetul de care avem nevoie <small><code>0x384</code></small>.</h5>
        <h5>Punand lucrurile cap la cap vom obtine adresa care ne intereseaza. Secventa de cod descrisa mai jos realizaeza acest lucru.</h5>
        <br>
        <div class="row">
          <div class="col-lg-6">
            <img src="src/p1-leak.png" style="width:100%;">
          </div>
          <div class="col-lg-6">
            <img src="src/p1-proof.png" style="width:100%;">
          </div>
        </div>
        <br>
        <br>
          <h5 style="color:#ff707f">2. Suprascrierea Zonei de Memorie</h5>
        <br>
        <h5>In cele din urma, nu ne mai ramane decat un singur lucru de facut, sa suprascriem octetii din zona de memorie alocata pentru <code>WASM</code> si sa o executam.</h5>
        <h5>Desi lucrul acesta la prima vedere pare destul de "straight-forward" (avand in vedere a doua vulnerabilitate care ne permite sa suprascriem o multime de octeti), in esenta este mai complicat deoarece Array-urile pe care le alocam nu se gasesc in acelasi bloc de memorie cu octetii pe care dorim sa-i suprascriem.</h5>
        <h5>Revenind la codul sursa, putem observa ca dupa ce sunt efectuate verificarile pentru parametrii, este invocata metoda <code>.fill()</code> , dar adresa la care sunt scrisi octetii, este luata prin proprietatea <code>->DataPtr()</code>.</h5>
        <br>
        <div class="row">
          <div class="col-lg-6">
            <img src="src/p1-fill.png" style="width:100%;">
          </div>
          <div class="col-lg-6">
            <img src="src/p1-fillptr.png" style="width:100%;">
          </div>
        </div>
        <br>
        <h5>Astfel planul devine urmatorul:</h5>
        <ul>
          <li>Construim doua Array-uri</li>
          <li>Determinam distanta dintre ele</li>
          <li>Folosim vulnerabilitatea de a suprascrie <code>out-of-bounds</code> pentru a suprascrie pointerul celui de-al doilea array cu zona de memorie <code>rwx</code></li>
          <li>Folosim metoda <code>.fill()</code> pentru a suprascrie zona de memorie.</li>
        </ul>
        <img src="src/p1-overwrite.png" style="width:100%">
        <br>     <br>
        <h5>In cele din urma, dupa suprascrierea buffer-ului cu <code>shellcode</code>, vom obtine <code>shell</code> .</h5>  
        <h5>Scriptul intreg poate fi gasit la adresa: <a href="https://github.com/Fineas/Me-CTF/blob/master/Writeups/20-confidence/solve_chromatic.js" style="color:#ff707f">https://github.com/Fineas/Me-CTF/blob/master/Writeups/20-confidence/solve_chromatic.js</a></h5>
        <h1><i class="fas fa-stamp"></i><span style="color:#17b06b"> CONCLUZIE</span></h1>
          <h5>Consider ca problema aceasta este una usoara si potrivita pentru a porni in acest domeniu.</h5>
          <h5>Nadajduiesc ca a fost cu prisos acest articol si ca au fost lucruri noi si interesante de invatat.</h5>
          <h5>Aceasta a fost prima mea tangenta cu scrierea articolelor, dar doresc sa continu acest lucru, a fost o experienta frumoasa üòÑ</h5>
        <h1><i class="fas fa-apple-alt"></i><span style="color:#17b06b"> RESURSE</span></h1>
        <ul>
          <li>https://source.chromium.org/chromium/chromium/src/+/master:v8/src/builtins</li>
          <li>https://abiondo.me/2019/01/02/exploiting-math-expm1-v8/#code-execution</li>
          <li>http://jayconrod.com/posts/52/a-tour-of-v8-object-representation</li>
          <li>http://richardartoul.github.io/jekyll/update/2015/04/26/hidden-classes.html</li>
          <li>https://tcode2k16.github.io/blog/posts/2020-03-15-confidence-ctf/#chromatic-aberration</li>
          <li>https://www.mattzeunert.com/2017/03/29/v8-object-size.html</li>
          <li>https://syedfarazabrar.com/2019-12-13-starctf-oob-v8-indepth/</li>
        </ul>
      </div>
  </div>

</div>



    <!-- Optional JavaScript -->
    <!-- jQuery first, then Popper.js, then Bootstrap JS -->

  <script src="https://code.jquery.com/jquery-3.3.1.slim.min.js" integrity="sha384-q8i/X+965DzO0rT7abK41JStQIAqVgRVzpbzo5smXKp4YfRvH+8abtTE1Pi6jizo" crossorigin="anonymous"></script>
  <script src="https://cdnjs.cloudflare.com/ajax/libs/popper.js/1.14.7/umd/popper.min.js" integrity="sha384-UO2eT0CpHqdSJQ6hJty5KVphtPhzWj9WO1clHTMGa3JDZwrnQq4sF86dIHNDz0W1" crossorigin="anonymous"></script>
  <script src="https://stackpath.bootstrapcdn.com/bootstrap/4.3.1/js/bootstrap.min.js" integrity="sha384-JjSmVgyd0p3pXB1rRibZUAYoIIy6OrQ6VrjIEaFf/nJGzIxFDsf4x0xIM+B07jRM" crossorigin="anonymous"></script>

  </body>
</html>
